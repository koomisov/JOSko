	Добрый день!
	
	В рамках решения индивидуального задания от Вас требуется реализовать поддержку вытеснения страниц оперативной памяти приложений 
	в специально выделенную область оперативной памяти ядра со сжатием при помощи одного из существующих алгоритмов. 
	Вытеснение страниц должно производиться по принципу LRU (вытесняются наименее часто используемые страницы). 
	Также в рамках выполнения задачи необходимо будет разработать функции печати текущего состояния виртуальной памяти для ядра 
	и пользовательских окружений с отражением информации об их "используемости" страниц, в том виде в котором она будет собираться для подсистемы swap'а.
	
	Работу над индивидуальным заданием необходимо вести в отдельной ветке
	itask. В эту ветку следует выложить дизайн-документ (в любом удобном
	формате txt[в кодировке UTF-8]/odt/pdf), в котором необходимо описать
	основные принципы предлагаемого решения и тесты, на которых оно будет
	проверяться. Всё, что необходимо для выполнения тестов, также надо
	выложить в эту ветку.
	
	Успехов, Хорошилов Алексей


                   * Описание задачи
Реализовать поддержку вытеснения страниц оперативной памяти приложений в специально
выделенную область оперативной памяти ядра со сжатием при помощи одного из известных
алгоритмов. Вытеснение страниц должно производиться по принципу LRU.



                  * Архитектура решения


                  ** Сжатие страниц
                  
Проанализировав известные алгоритмы сжатия без потерь, 
я выбрал алгоритм lz4, так как данный алгоритм обладает наилучшим соотношением 
скорость / степень сжатия

https://github.com/lz4/lz4

Используется специальный буфер для сжатия, так как сжатие требует больше памяти, чем исходная информация

Используются функции:
int LZ4_compressBound(int isize);
int LZ4_compress_default(const char* src, char* dst, int srcSize, int maxOutputSize);
int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)



                ** Реализация LRU
                
Добавлена структура LRU_list.
Была изменена структура PageInfo добавлены поля 
	struct PageInfo *lru_prev;
   	struct PageInfo *lru_next;

Были добавлены функции:
void add_to_lru_list(struct PageInfo *pg);
void delete_from_lru_list(struct PageInfo *pg);

При аллоцировании страницы, страница добавляется в начало списка. (add_to_lru_list)
При вызове page_insert, страница перемещается в начало списка. (delete_from_lru_list + add_to_lru_list)

Таким образом поддерживается актуальность LRU - списка.



                ** Область памяти для хранения откаченных страниц
             
Памать в ядре для хранения откаченных страниц выделяется при помощи boot_alloc в функции mem_init 
и затем отображается в виртуальной памяти при помощи boot_map_region. Для это был подвинут вниз и выровнен ULIM.
(смотри memlayout.h) 



                ** Начало процесса откачки
            
Как только список свободных страниц заканчивается, запускается функции swap_workout(), 
которая запускает процесс откачки страниц и добавляет новые свободные.

Функия swap_workout откачивает первые SWAP_AMOUNT страниц по принципу LRU.
Для каждой откаченной страницы функция циклически проходит по всем каталогам и таблицам страниц 
и изменяет pte_t тех виртуальный адресов, которые ссылаются на данную физическую страницу.

Замена pte_t происходит следующим образом, убирается флаг PTE_P и добавляется флаг PTE_W.
JOS не использует флаг PTE_W, по этому договоримся о следующем соглашении: флаг PTE_W обозначает 
откаченную в область swap страницу.
Остальные флаги оставим неизмененными.
Для каждой k-ой страницы pte_t формируется слудующим образом:
    
    pte_t *tmp = pgdir_walk(pgdir, PGADDR(i, j, 0), 0);
    *tmp = (k << 12) | (*tmp & 0xFFF);
    *tmp &= ~PTE_P;
    *tmp |= PTE_W;


Для каждого pte_t вызываем page_decref(page), таким образом, страница освободится к концу цикла.

Получается, что теперь обращение по виртуальному адресу, соответствующему откаченной странице будет 
вызывать page fault.




                   ** Обработка Page Fault
                   
Обработка page fault происходит в функции 
void
page_fault_handler(struct Trapframe *tf)

Просходит откачивание и декомпрессия нужной страницы в буфер сжатия.

Затем дефрагментация области swap-a

Потом откачивается в swap самая неиспользуемая страница (таким образом, появляется свободная 
в page_free_list). При помощи page_alloc выделяем страницу и копируем в нее содержимое из 
буфера сжатия.

Наконец, формуруем новый корректный pte_t: 
Добавляем корректный адрес страницы, убираем флаг PTE_W и добавляем флаг PTE_P
Добавляем страницу в начало списка (add_to_lru_list)




                *Тестирование
                    
При вызове swap_init тестируется алгоритм сжатия на качество сжатия и корректность.

Реализована функция check_swap(), которая аллоцирует всю возможную оперативную память



                *Мониторинг
                
Была изменена структура Env

struct Env {
	struct Trapframe env_tf;	// Saved registers
	struct Env *env_link;		// Next free Env
	envid_t env_id;			// Unique environment identifier
	envid_t env_parent_id;		// env_id of this env's parent
	enum EnvType env_type;		// Indicates special system environments
	unsigned env_status;		// Status of the environment
	uint32_t env_runs;		// Number of times environment has run
	pde_t *env_pgdir;		// Kernel virtual address of page dir

	// Exception handling
	void *env_pgfault_upcall;	// Page fault upcall entry point

	bool env_ipc_recving;		// Env is blocked receiving
	void *env_ipc_dstva;		// VA at which to map received page
	uint32_t env_ipc_value;		// Data value sent to us
	envid_t env_ipc_from;		// envid of the sender
	int env_ipc_perm;		// Perm of page mapping received
	int swap_pages;  - добавлено поле
};

